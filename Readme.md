# Readme
### Инструменты
- Java 11
- Maven
- Spring Boot/Web/Data/Test/Actuator
- JUnit 5
- MongoDB
- Jackson Core

### Запуск
TesttaskApplication -> Run

Корень контекста и порт указаны в пропертях

База находится в облаке, все должно работать из коробки

Корневой адрес:
**localhost:8189/api/**

### Архитектура
Проект традиционно разбит на три слоя - Контроллер, Сервис и Репозиторий
Контроллер выполняет лишь первичную валидацию, чтобы снизить неполезную нагрузку на сервис и репозиторий. Поскольку фронт не предоставлен и фронт можно обойти без каких-либо затруднений, предполагается, что валидации на фронте нет.
Сервис проводит дополнительную валидацию и предоставляет абстракцию над реализацией контактной книжки.
Репозиторий расширяет MongoRepository и пользуется его методами практически полностью, за исключением одного метода на поиск имени, содержащему указаный запрос
### Пояснение к коду
Когда я смотрел технологический стек вашей компании, я заметил, что вы предпочитаете использовать MongoDB в своих проектах, поэтому решил, что будет правильнее если я буду использовать ту СУБД, которую принято использовать у Вас, хоть я и не был с ней знаком, чем вынуждать Вас ознакамливаться с СУБД, которая для вас непривычна
В целом Spring Data делает безразличной СУБД работающую по ту сторону подключения, однако между классическими MySQL/Postgres и MongoDB есть одно очень большое различие - первые реляционны, а последняя - документоориентированна. Поэтому я принял решение не использовать нереляционную БД в реляционном стиле и хранить список контактов каждого пользователя как вложенный документ, обычный List контактов как поле пользователя
По этой же причине контроллер разделен на два класса - контроллер пользователей и контроллер контактов, а сервис и репозиторий на контакты и пользователей не разделены, потому что контакты представляют собой неотделимую от пользователей сущность.
**Кроме того, MongoDB сразу предоставляет онлайн-хостинг и не требуется ничего докеризировать или тем более пересылать по фрагментам**
##### Структура Пользователя
- id
- имя
- список контактов

##### Структура контакта
- id*
- имя
- номер телефона

id представляет собой Java UUID, т.к. MongoDB насколько мне известно не генерирует id для вложенных документов
### Тесты
Тесты поделены на два класса - тест эндпоинтов контактов и эндпоинтов пользователей
Тестируется не сервис или контроллер, а эндпоинты напрямую. У меня довольно скудный опыт тестирования веб-приложений, но я основываюсь на предположении, что для конечного пользователя важнее всего корректная работа эндпоинтов и как бы хорошо не выполняли свою работу сервис или контроллер - если пользователь не получает нужные данные по запросу, то тест должен быть провален. Я могу ошибаться и с радостью научился бы тестировать это всё гораздо лучше. Тесты могут показаться громоздкими и чем-то друг друга повторяющими. Это вызвано тем, что каждый тест последователен - сначала делается попытка создания объекта, а уже потом его получения или каких-то операций с ним. И если ошибку во всех тестах вызовет создание - тесты предупредят о том, где искать ошибку, а не только о ее факте. Например если при тестировании редактирования ошибку выдаст само создание объекта, то тесты сразу предупредят, что сломано как раз создание объекта, а вовсе необязательно его редактирование. Возможно это тоже избыточно и делает тесты гораздо менее читаемыми, зато ускоряет проваленные тесты (за счет того что первая ошибочная операция в каждом тесте сразу его останавливает), и ускоряет починку поломанного в процессе разработки функционала. Я исхожу из предположения, что тесты приходится переписывать реже чем код, который они проверяют :)
Так же в тестах лежат проекции соответствующих классов. Это вызвано тем, что ObjectMapper, превращающий в тестах ответы с эндпоинтов в java-объекты требует открытые поля и конструкторы. Делать такое с настоящими объектами я не готов по соображениям безопасности, но легковесные проекции показались мне удобным решением в такой ситуации. Сама IDEA не видит использование конструкторов Маппером, поэтому выдает предупреждение. Из двух вариантов - написание инспекции или отключение предупреждений unused в классе проекции, был выбран второй.
### REST - эндпоинты
**localhost:8189**
Я пытался задокументировать их через Swagger, но к сожалению он часть эндпоинтов видел как Proxy из-за Спринга или возможно из-за конкретно Репозитория. Поэтому, к сожалению, я перечислю их здесь.
**Кроме того, к проекту подключен актуатор - все эндпоинты видны в IDEA, никакие дополнительные действия не требуются**
Все запросы возвращают нужный Status Code:
Обычно он OK
Если ресурс не найден, то 404
Если объект успешно создан, то 201
Если отредактирован, то 204 (NO_CONTENT корректный код возврата при PUT)
Если для создания или редактирование поданы некорректные данные, то 422
Если запрос некорректен, то 400

#### User
**GET /api/users**
Возвращает список пользователей

**GET /api/users?searchQuery=**
Возвращает список пользователей содержащих в имени поисковой запрос
При ответе пользователи сортируются по совпадению таким образом, что первый в списке гарантированно совпадающий полностью(если он вообще существует)
Вернет 404, если ни одного такого пользователя нет.
Не возвращает список контактов

**GET /api/users/{id}**
Возвращает пользователя с указаным Id или 404, если такого нет
Не возвращает список контактов

**POST /api/users?name=**
Создает пользователя с указанным именем. Не создаст ничего и вернет 422, если имя длиннее 100 символов. Возвращает дополнительный Header со ссылкой на новую сущность, согласно спецификации REST

**PUT /api/users/{id}?newName=**
Редактирует пользователя с указанным id. Вернет 404, если пользователя нет и 422 если имя длиннее 100 символов. Так же вернет 400, если параметр не указан в принципе. Не смотря на то, что put должен создавать пользователя при его отсутствии, этот запрос вернет 404 при его отстуствии. Возможно это неправильно, я могу это исправить, но меня убедили в том, что Patch не используют практически для этих целей нигде и более того он не потокобезопасен, поэтому было принято решение использовать PUT и не использовать Patch вообще. К сожалению настоящего опыта у меня нет поэтому я не могу быть уверенным, что это правильное решение :(

**DELETE /api/users/{id}**
Возвращает 204, если удаление прошло успешно и 404 если удалять оказалось нечего
#### Contract
**GET /api/users/{userId}/contacts**
Вернет список пользователей контакта. Если список пуст, то вернет просто пустой список

**GET /api/users/{userId}/contacts?searchQuery=**
Вернет контакт полностью совпадающий по номеру с searchQuery. Или 404, если такого нет

**GET /api/users/{userId}/contacts/{contactId}**
Вернет контакт с указанным id. Или 404, если такого контакта нет

**POST /api/users/{userId}/contacts?name=&number=**
Создает контактов с указанными именем и номером.
Вернет ОК если создание прошло успешно и 422, если номер не является номером, или имя длиннее 100 символов
Если не указать параметры вернет 400
Аналогично возвращает адрес новой сущности

**PUT /api/users/{userId}/contacts/{contactId}?newName=&newNumber=**
Вернет NO_CONTENT, если прошел успешно, 404, если контакта или пользователя нет, 400 если не указать НИ один из этих параметров или 422 если номер или имя будут некорректны.

**DELETE /api/users/{userId}/contacts/{contactId}**
Удаляет контакт если все хорошо и возвращает NO_CONTENT. Если контакта или пользователя вовсе не было, то вернет 404.







